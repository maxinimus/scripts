#!/bin/bash

# Variables
semester_path="/Users/maxinimus/Documents/university/3_year/2_semester"
resume_path="~/Documents/resume"
default_latex_file_to_edit="content.tex"
fallback_latex_file="main.tex"
default_typst_file_to_edit="main.typ"
fallback_typst_file="template.typ"

server_name="mlavrenk@data.cs.purdue.edu"

courst_list=$(ls -1 $semester_path | grep -v '^TA-')
course=""

remaining_args=()
argument=""

default_file_to_edit="$default_typst_file_to_edit"
fallback_file_to_edit="$fallback_typst_file"
# Initialize default flag values
create_flag=false
change_dir_flag=false
here_flag=false
here_fallback_flag=false
resume_flag=false
grr_flag=false
typst_flag=false
latex_flag=false

# Verbose mode
verbose=false

prompt_choose_course() {
  # Lists directories (courses) and lets the user choose one
  echo "Courses:"
  i=1
  while IFS= read -r line; do
    echo "$i: $line"
    i=$((i+1))
  done <<< "$course_list"

  echo "Choose the course:"
  read user_choice

  while ! [[ $user_choice =~ ^[0-9]+$ ]]; do
    echo "Not a number"
    echo "Choose the course:"
    read user_choice
  done

  course=$(echo "$course_list" | sed -n "${user_choice}p")
  if [ "$verbose" = true ]; then
    echo "Chosen course: $course"
  fi
}

# Individual handler functions
handle_flag_create() {
  echo "create flag is not working yet"
  # make it so that . is a valid argument, create a new directory here
}

handle_flag_change_dir() {
  # if argument is empty, just cd to the semester path
  directory_to_cd="$semester_path"
  if [ ! -z "$argument" ]; then
    directory_to_cd="$semester_path/$argument"
  fi

  if [ "$verbose" = true ]; then
    echo "Changing directory to $directory_to_cd"
  fi

  cd "$directory_to_cd" || { echo "Error: Failed to change directory to $directory_to_cd"; return 1; }
}

handle_flag_here() {
  #open_file_with_nvim || { echo "Error: Failed in opening file after changing to $default_file_to_edit"; return 1; }
  # instead of a flag, just use .
  echo "here flag is not working yet"
}

handle_flag_here_fallback() {
  default_file_to_edit="$fallback_file_to_edit"
  open_file_with_nvim || { echo "Error: Failed in opening file after changing to fallback $fallback_file_to_edit"; return 1; }
}

handle_flag_resume() {
  cd "$resume_path" || { echo "Error: Failed to change directory to $resume_path"; return 1; }
}

handle_flag_grr() {
  ssh "$server_name" || { echo "Error: Failed to SSH into $server_name"; return 1; }
}

handle_flag_typst() {
  default_file_to_edit="$default_typst_file_to_edit"
  fallback_file_to_edit="$fallback_typst_file"
}

handle_flag_latex() {
  default_file_to_edit="$default_latex_file_to_edit"
  fallback_file_to_edit="$fallback_latex_file"
}

open_file_with_nvim() {
  # Check if the file exists
  if [ ! -f "$default_file_to_edit" ]; then
    if [ ! -f "$default_file_to_edit" ]; then
      echo "Error: Neither $default_file_to_edit nor $fallback_file_to_edit exists."
      return
    fi
  fi

  if [ "$typst_flag" = true ]; then
    nvim "$default_file_to_edit" \
        -c ':lua require("nvterm.terminal").send("typst watch main.typ", "horizontal")' \
        -c ':lua vim.fn.jobstart({"zsh", "-c", "source ~/.zshrc && pdf main"}, {detach = true})' 
  fi

  if [ "$latex_flag" = true ]; then
    nvim "$default_file_to_edit" \
        -c ':set filetype=tex' \
        -c ':VimtexCompile' \
        -c ':bnext'
  fi
}

# Handle flags
handle_flags() {
  # Call all flag handlers and check logic
  
  # if both typst_flag and latex_flag are set, return an error
  if [ "$typst_flag" = true ] && [ "$latex_flag" = true ]; then
    echo "Error: Both typst and latex flags cannot be set at the same time."
    return 1
  fi
  # if both create_flag and change_dir_flag are set, return an error
  if [ "$create_flag" = true ] && [ "$change_dir_flag" = true ]; then
    echo "Error: Both create and change_dir flags cannot be set at the same time."
    return 1
  fi

  if [ "$typst_flag" = true ]; then
    handle_flag_typst
  fi 
  if [ "$latex_flag" = true ]; then
    handle_flag_latex
  fi

  # if neither typst_flag nor latex_flag is set, set typst_flag to true
  if [ "$typst_flag" = false ] && [ "$latex_flag" = false ]; then
    echo "Error: Neither typst nor latex flag is set. Defaulting to typst."
    typst_flag=true
    # TODO: change it to dynamically set the flag
  fi

  if $grr_flag; then
    handle_flag_grr || { echo "Error in handle_flag_grr"; return 1; }
    return 0
  fi

  $resume_flag && { handle_flag_resume || { echo "Error in handle_flag_resume"; return 1; }; }
  $change_dir_flag && { handle_flag_change_dir || { echo "Error in handle_flag_change_dir"; return 1; }; }
  $create_flag && { handle_flag_create || { echo "Error in handle_flag_create"; return 1; }; }
  $here_flag && { handle_flag_here || { echo "Error in handle_flag_here"; return 1; }; }
  $here_fallback_flag && { handle_flag_here_fallback || { echo "Error in handle_flag_here_fallback"; return 1; }; }
}

# Parse flags
parse_flags() {
  # Parse command-line flags
  while getopts "cdhmrgtlv" opt; do
    case "$opt" in
      c) create_flag=true ;;
      d) change_dir_flag=true ;;
      h) here_flag=true ;;
      m) here_fallback_flag=true ;;
      r) resume_flag=true ;;
      g) grr_flag=true ;;
      t) typst_flag=true ;;
      l) latex_flag=true ;;
      v) verbose=true ;;
      \?) echo "Invalid option"; return 1 ;;
    esac
  done

  if [ "$verbose" = true ]; then
    echo "Verbose mode is enabled."
  fi

  if [ "$verbose" = true ]; then
    echo "create_flag: $create_flag"
    echo "change_dir_flag: $change_dir_flag"
    echo "here_flag: $here_flag"
    echo "here_fallback_flag: $here_fallback_flag"
    echo "resume_flag: $resume_flag"
    echo "grr_flag: $grr_flag"
    echo "typst_flag: $typst_flag"
    echo "latex_flag: $latex_flag"
    echo "---------------------"
  fi

  shift $((OPTIND - 1))
  remaining_args=("$@")
  argument="${remaining_args[@]}" 

  if [ "${#remaining_args[@]}" -gt 1 ]; then
    echo "Error: More than one argument provided."
    return 1
  fi
  
  if [ "verbose" = true ]; then
    echo "Non-flag arguments: ${remaining_args[@]}"
  fi
}

# Main logic
main() {
  # Parse command-line flags
  parse_flags "$@" || { echo "error parsing flags"; return 1; }

  # Load course name from the argument
  course=$(echo "$course_list" | grep -i "$argument")

  # Handle flags
  handle_flags || { echo "error handling flags"; return 1; }
}

main "$@"
